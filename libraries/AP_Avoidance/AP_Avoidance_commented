#include "AP_Avoidance.h"

#if HAL_ADSB_ENABLED

extern const AP_HAL::HAL& hal;

#include <limits>
#include <AP_AHRS/AP_AHRS.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_Vehicle/AP_Vehicle_Type.h>

#define AVOIDANCE_DEBUGGING 0

#if APM_BUILD_TYPE(APM_BUILD_ArduPlane)
    // Default values for ArduPlane
    #define AP_AVOIDANCE_WARN_TIME_DEFAULT              30
    #define AP_AVOIDANCE_FAIL_TIME_DEFAULT              30
    #define AP_AVOIDANCE_WARN_DISTANCE_XY_DEFAULT       1000
    #define AP_AVOIDANCE_WARN_DISTANCE_Z_DEFAULT        300
    #define AP_AVOIDANCE_FAIL_DISTANCE_XY_DEFAULT       300
    #define AP_AVOIDANCE_FAIL_DISTANCE_Z_DEFAULT        100
    #define AP_AVOIDANCE_RECOVERY_DEFAULT               RecoveryAction::RESUME_IF_AUTO_ELSE_LOITER
    #define AP_AVOIDANCE_FAIL_ACTION_DEFAULT            MAV_COLLISION_ACTION_REPORT
#else // Defaults for Copter, Heli, Rover, Boat
    #define AP_AVOIDANCE_WARN_TIME_DEFAULT              30
    #define AP_AVOIDANCE_FAIL_TIME_DEFAULT              30
    #define AP_AVOIDANCE_WARN_DISTANCE_XY_DEFAULT       300
    #define AP_AVOIDANCE_WARN_DISTANCE_Z_DEFAULT        300
    #define AP_AVOIDANCE_FAIL_DISTANCE_XY_DEFAULT       100
    #define AP_AVOIDANCE_FAIL_DISTANCE_Z_DEFAULT        100
    #define AP_AVOIDANCE_RECOVERY_DEFAULT               RecoveryAction::RTL
    #define AP_AVOIDANCE_FAIL_ACTION_DEFAULT            MAV_COLLISION_ACTION_REPORT
#endif

#if AVOIDANCE_DEBUGGING
#include <stdio.h>
#define debug(fmt, args ...)  do {::fprintf(stderr,"%s:%d: " fmt "\n", __FUNCTION__, __LINE__, ## args); } while(0)
#else
#define debug(fmt, args ...)
#endif

// Table of user-settable parameters
const AP_Param::GroupInfo AP_Avoidance::var_info[] = {

    // Enable Avoidance using ADSB
    // 0: Disabled, 1: Enabled
    AP_GROUPINFO_FLAGS("ENABLE", 1, AP_Avoidance, _enabled, 0, AP_PARAM_FLAG_ENABLE),

    // Collision Avoidance Behavior
    // Specifies aircraft behavior when a collision is imminent
    // 0: None, 1: Report, 2: Climb Or Descend, 3: Move Horizontally, 4: Move Perpendicularly in 3D, 5: RTL, 6: Hover
    AP_GROUPINFO("F_ACTION", 2, AP_Avoidance, _fail_action, AP_AVOIDANCE_FAIL_ACTION_DEFAULT),

    // Collision Avoidance Behavior - Warn
    // Specifies aircraft behavior when a collision may occur
    // 0: None, 1: Report
    AP_GROUPINFO("W_ACTION", 3, AP_Avoidance, _warn_action, MAV_COLLISION_ACTION_REPORT),

    // Recovery behavior after a fail event
    // 0: Remain in AVOID_ADSB, 1: Resume previous flight mode, 2: RTL, 3: Resume if AUTO else Loiter
    AP_GROUPINFO("F_RCVRY", 4, AP_Avoidance, _fail_recovery, uint8_t(AP_AVOIDANCE_RECOVERY_DEFAULT)),

    // Maximum number of obstacles to track
    AP_GROUPINFO("OBS_MAX", 5, AP_Avoidance, _obstacles_max, 20),

    // Time Horizon Warn
    // Aircraft velocity vectors are multiplied by this time to determine closest approach
    // If this results in an approach closer than W_DIST_XY or W_DIST_Z then W_ACTION is undertaken
    AP_GROUPINFO("W_TIME", 6, AP_Avoidance, _warn_time_horizon, AP_AVOIDANCE_WARN_TIME_DEFAULT),

    // Time Horizon Fail
    // Aircraft velocity vectors are multiplied by this time to determine closest approach
    // If this results in an approach closer than F_DIST_XY or F_DIST_Z then F_ACTION is undertaken
    AP_GROUPINFO("F_TIME", 7, AP_Avoidance, _fail_time_horizon, AP_AVOIDANCE_FAIL_TIME_DEFAULT),

    // Distance Warn XY
    // Closest allowed projected distance before W_ACTION is undertaken
    AP_GROUPINFO("W_DIST_XY", 8, AP_Avoidance, _warn_distance_xy, AP_AVOIDANCE_WARN_DISTANCE_XY_DEFAULT),

    // Distance Fail XY
    // Closest allowed projected distance before F_ACTION is undertaken
    AP_GROUPINFO("F_DIST_XY", 9, AP_Avoidance, _fail_distance_xy, AP_AVOIDANCE_FAIL_DISTANCE_XY_DEFAULT),

    // Distance Warn Z
    // Closest allowed projected distance before BEHAVIOUR_W is undertaken
    AP_GROUPINFO("W_DIST_Z", 10, AP_Avoidance, _warn_distance_z, AP_AVOIDANCE_WARN_DISTANCE_Z_DEFAULT),

    // Distance Fail Z
    // Closest allowed projected distance before BEHAVIOUR_F is undertaken
    AP_GROUPINFO("F_DIST_Z", 11, AP_Avoidance, _fail_distance_z, AP_AVOIDANCE_FAIL_DISTANCE_Z_DEFAULT),
    
    // ADS-B avoidance minimum altitude
    // Minimum AMSL altitude for ADS-B avoidance. No avoidance action will take place below this altitude.
    AP_GROUPINFO("F_ALT_MIN", 12, AP_Avoidance, _fail_altitude_minimum, 0),

    AP_GROUPEND
};

// Constructor for AP_Avoidance
AP_Avoidance::AP_Avoidance(AP_ADSB &adsb) :
    _adsb(adsb)
{
    AP_Param::setup_object_defaults(this, var_info);
    if (_singleton != nullptr) {
        AP_HAL::panic("AP_Avoidance must be singleton");
    }
    _singleton = this;
}

/*
 * Initialize variables and allocate memory for the obstacle array
 */
void AP_Avoidance::init(void)
{
    debug("ADSB initialisation: %d obstacles", _obstacles_max.get());
    if (_obstacles == nullptr) {
        _obstacles = new AP_Avoidance::Obstacle[_obstacles_max];

        if (_obstacles == nullptr) {
            // Dynamic RAM allocation of _obstacles[] failed, disable gracefully
            DEV_PRINTF("Unable to initialize Avoidance obstacle list\n");
            // Disable ourselves to avoid repeated allocation attempts
            _enabled.set(0);
            return;
        }
        _obstacles_allocated = _obstacles_max;
    }
    _obstacle_count = 0;
    _last_state_change_ms = 0;
    _threat_level = MAV_COLLISION_THREAT_LEVEL_NONE;
    _gcs_cleared_messages_first_sent = std::numeric_limits<uint32_t>::max();
    _current_most_serious_threat = -1;
}

/*
 * De-initialize and free up some memory
 */
void AP_Avoidance::deinit(void)
{
    if (_obstacles != nullptr) {
        delete [] _obstacles;
        _obstacles = nullptr;
        _obstacles_allocated = 0;
        handle_recovery(RecoveryAction::RTL);
    }
    _obstacle_count = 0;
}

/*
 * Check if the avoidance system should start up
 */
bool AP_Avoidance::check_startup()
{
    if (!_enabled) {
        if (_obstacles != nullptr) {
            deinit();
        }
        // Nothing to do
        return false;
    }
    if (_obstacles == nullptr)  {
        init();
    }
    return _obstacles != nullptr;
}

/*
 * Add an obstacle to the tracking system
 * vel is north/east/down!
 */
void AP_Avoidance::add_obstacle(const uint32_t obstacle_timestamp_ms,
                                const MAV_COLLISION_SRC src,
                                const uint32_t src_id,
                                const Location &loc,
                                const Vector3f &vel_ned)
{
    if (! check_startup()) {
        return;
    }
    uint32_t oldest_timestamp = std::numeric_limits<uint32_t>::max();
    uint8_t oldest_index = 255; // Avoid compiler warning with initialization
    int16_t index = -1;
    uint8_t i;
    for (i=0; i<_obstacle_count; i++) {
        if (_obstacles[i].src_id == src_id &&
            _obstacles[i].src == src) {
            // Pre-existing obstacle found; update its information
            index = i;
            break;
        }
        if (_obstacles[i].timestamp_ms < oldest_timestamp) {
            oldest_timestamp = _obstacles[i].timestamp_ms;
            oldest_index = i;
        }
    }
    WITH_SEMAPHORE(_rsem);
    
    if (index == -1) {
        // Existing obstacle not found. See if we can store it anyway:
        if (i <_obstacles_allocated) {
            // Have room to store more vehicles...
            index = _obstacle_count++;
        } else if (oldest_timestamp < obstacle_timestamp_ms) {
            // Replace this very old entry with new data
            index = oldest_index;
        } else {
            // No room for this (old?!) data
            return;
        }

        _obstacles[index].src = src;
        _obstacles[index].src_id = src_id;
    }

    _obstacles[index]._location = loc;
    _obstacles[index]._velocity = vel_ned;
    _obstacles[index].timestamp_ms = obstacle_timestamp_ms;
}

/*
 * Add an obstacle to the tracking system
 */
void AP_Avoidance::add_obstacle(const uint32_t obstacle_timestamp_ms,
                                const MAV_COLLISION_SRC src,
                                const uint32_t src_id,
                                const Location &loc,
                                const float course_over_ground_cd,
                                const float hor_velocity_cm,
                                const float vert_velocity_cm)
{
    float cog_radians = radians(course_over_ground_cd * 0.01f);
    Vector3f vel = Vector3f(hor_velocity_cm * cosf(cog_radians),
                            hor_velocity_cm * sinf(cog_radians),
                            vert_velocity_cm);
    add_obstacle(obstacle_timestamp_ms, src, src_id, loc, vel);
}

/*
 * Update threat level of an obstacle based on its location
 */
void AP_Avoidance::update_threat_level(const Location &my_loc, const Vector3f &my_vel_ned, AP_Avoidance::Obstacle &obstacle)
{
    float threat = MAV_COLLISION_THREAT_LEVEL_NONE;
    float distance_xy;
    float distance_z;
    float velocity_diff;

    if (my_vel_ned.is_zero() && obstacle._velocity.is_zero()) {
        // Do nothing
        return;
    }

    distance_xy = closest_approach_xy(my_loc, my_vel_ned, obstacle._location, obstacle._velocity);
    distance_z = closest_approach_z(my_loc, my_vel_ned, obstacle._location, obstacle._velocity);

    if (distance_xy < _fail_distance_xy && distance_z < _fail_distance_z) {
        threat = MAV_COLLISION_THREAT_LEVEL_IMMINENT;
    } else if (distance_xy < _warn_distance_xy && distance_z < _warn_distance_z) {
        threat = MAV_COLLISION_THREAT_LEVEL_HIGH;
    }

    if (obstacle.threat_level != threat) {
        obstacle.threat_level = threat;
    }
}

/*
 * Returns the closest approach distance in meters
 */
float closest_approach_xy(const Location &my_loc,
                          const Vector3f &my_vel,
                          const Location &obs_loc,
                          const Vector3f &obs_vel)
{
    Vector2f p_obs(obs_loc.lon - my_loc.lon, obs_loc.lat - my_loc.lat);
    p_obs *= (double) LOCATION_SCALING_FACTOR;
    Vector2f v_obs(obs_vel.x - my_vel.x, obs_vel.y - my_vel.y);
    float a = v_obs.x * v_obs.x + v_obs.y * v_obs.y;
    float b = 2 * (v_obs.x * p_obs.x + v_obs.y * p_obs.y);
    float tca = -b / (2 * a);

    if (tca < 0) {
        // closest approach was in the past; actual distance is now:
        return p_obs.length();
    } else {
        return fabsf((p_obs + tca * v_obs).length());
    }
}

/*
 * Returns the closest approach distance in meters
 */
float closest_approach_z(const Location &my_loc,
                         const Vector3f &my_vel,
                         const Location &obs_loc,
                         const Vector3f &obs_vel)
{
    float dz = obs_loc.alt - my_loc.alt;
    float dv = obs_vel.z - my_vel.z;
    float tca = -dz / dv;

    if (tca < 0) {
        // closest approach was in the past; actual distance is now:
        return dz;
    } else {
        return fabsf(dz + tca * dv);
    }
}

/*
 * Main update loop
 */
void AP_Avoidance::update()
{
    if (!check_startup()) {
        return;
    }

    if (_adsb.enabled()) {
        get_adsb_samples();
    }

    check_for_threats();

    // Avoid object (if necessary)
    handle_avoidance_local(most_serious_threat());

    // Notify GCS of most serious threat
    handle_threat_gcs_notify(most_serious_threat());
}

/*
 * Get ADSB samples
 */
void AP_Avoidance::get_adsb_samples()
{
    uint8_t i;
    for (i=0; i<_adsb.get_vehicle_count(); i++) {
        const struct AD_Aircraft *aircraft = _adsb.get_aircraft(i);
        if (aircraft->ts <= 0) {
            continue;
        }
        // Add obstacle to the list
        add_obstacle(aircraft->ts,
                     MAV_COLLISION_SRC_ADSB,
                     aircraft->address,
                     aircraft->loc,
                     aircraft->vel);
    }
}

/*
 * Compare if an obstacle is more serious threat than the current one
 */
bool AP_Avoidance::obstacle_is_more_serious_threat(const AP_Avoidance::Obstacle &obstacle) const
{
    if (obstacle.threat_level > _threat_level) {
        return true;
    }
    if (obstacle.threat_level == _threat_level) {
        if (_current_most_serious_threat == -1) {
            // Initial case
            return true;
        }
        if (obstacle.timestamp_ms < _obstacles[_current_most_serious_threat].timestamp_ms) {
            // Older information is more reliable
            return true;
        }
    }
    return false;
}

/*
 * Find and check for threats
 */
void AP_Avoidance::check_for_threats()
{
    int16_t index = -1;
    const struct Location &my_loc = hal.ahrs->get_location();
    Vector3f my_vel_ned = hal.ahrs->get_velocity();

    // Identify the most serious threat
    for (uint8_t i=0; i<_obstacle_count; i++) {
        update_threat_level(my_loc, my_vel_ned, _obstacles[i]);
        if (obstacle_is_more_serious_threat(_obstacles[i])) {
            _current_most_serious_threat = i;
            _threat_level = _obstacles[i].threat_level;
        }
    }
}

/*
 * Handle avoidance locally
 */
void AP_Avoidance::handle_avoidance_local(AP_Avoidance::Obstacle *threat)
{
    if (threat == nullptr) {
        return;
    }

    if (threat->threat_level == MAV_COLLISION_THREAT_LEVEL_IMMINENT) {
        // Perform failure action
        perform_fail_action();
    } else if (threat->threat_level == MAV_COLLISION_THREAT_LEVEL_HIGH) {
        // Perform warning action
        perform_warn_action();
    }
}

/*
 * Notify GCS of the most serious threat
 */
void AP_Avoidance::handle_threat_gcs_notify(AP_Avoidance::Obstacle *threat)
{
    if (threat == nullptr) {
        return;
    }

    if (_threat_level != MAV_COLLISION_THREAT_LEVEL_NONE) {
        mavlink_msg_collision_send(
            chan,
            _adsb.get_system_id(),
            _adsb.get_component_id(),
            threat->src_id,
            threat->src,
            _threat_level,
            threat->_location.lat,
            threat->_location.lon,
            threat->_location.alt,
            threat->_velocity.x,
            threat->_velocity.y,
            threat->_velocity.z
        );
    }
}

/*
 * Handle incoming MAVLink messages
 */
void AP_Avoidance::handle_msg(const mavlink_message_t &msg)
{
    switch (msg.msgid) {
    case MAVLINK_MSG_ID_COLLISION:
        mavlink_collision_t collision;
        mavlink_msg_collision_decode(&msg, &collision);

        // Convert to Location and Vector3f
        Location loc(collision.latitude, collision.longitude, collision.altitude);
        Vector3f vel(collision.vel_x, collision.vel_y, collision.vel_z);

        add_obstacle(hal.scheduler->millis(), MAV_COLLISION_SRC_MAVLINK, collision.id, loc, vel);
        break;
    }
}

#endif // HAL_ADSB_ENABLED
